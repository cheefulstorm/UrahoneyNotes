## 线程控制

### 线程概念

LWP：light weight process 轻量级的进程，**本质仍是进程**(在Linux环境下)

**进程：独立地址空间，拥有PCB** 

**线程：有独立的PCB，但没有独立的地址空间(共享)**

区别：在于是否共享地址空间。    独居(进程)；合租(线程)。

<img src="../../assets/image-20230309173327898.png" alt="image-20230309173327898" style="zoom:150%;" />

Linux下：线程：最小的执行单位；进程：最小分配资源单位，可看成是只有一个线程的进程。



### Linux内核中线程的实现原理

类Unix系统中，早期是没有“线程”概念的，80年代才引入，借助进程机制实现出了线程的概念。因此在这类系统中，进程和线程关系密切。

* 轻量级进程(light-weight process)，也有PCB，创建线程使用的底层函数和进程一样，都是clone

* **从内核里看进程和线程是一样的，都有各自不同的PCB，但是PCB中指向内存资源的三级页表是相同的**

* 进程可以蜕变成线程

* 线程可看做寄存器和栈的集合

* 在linux下，线程最是小的执行单位；进程是最小的分配资源单位

察看LWP号：ps –Lf pid 查看指定线程的lwp号。

> fork创建子进程时父子进程的三级页表虽然相同，实际上父子进程是**指向不同的三级页表，只是内容相同**，一旦其中一个进程修改内容，通过COW机制，父子进程的页表信息就出现差别，因此，父子进程不能共享进程的用户地址空间，
>
> 而同一个进程的两个线程**指向同一个三级页表**，不会出现这种情况，因此，线程可以共享进程的用户的地址空间



### 线程共享和不共享的资源

共享：

* 文件描述符表 

* **每种信号的处理方式**

  > 如果给一个多线程的进程发送信号，哪个线程抢到信号就谁处理

* 当前工作目录

* 用户ID和组ID

* 内存地址空间 (.text/.data/.bss/heap/共享库，**不包括栈**)

不共享：

* 线程id

* 处理器现场和栈指针(内核栈)

* 独立的栈空间(用户空间栈)

* **errno变量**

  > 虽然errno是全局变量，但是线程不共享

* **信号屏蔽字**

  > 由于线程可以设置不同的信号屏蔽字，故如果给一个多线程的进程发送信号，通过设置不同的信号屏蔽字，可以控制由哪个线程处理信号
  >
  > 但是不推荐线程和信号混用，信号设计之时线程还不存在，两者不是很兼容

* 调度优先级 



### 线程优缺点

​    优点：  1. 提高程序并发性    2. 开销小    3. 数据通信、共享数据方便

​    缺点：  1. 库函数（线程相关的函数不是系统调用），不稳定    2. **调试、编写困难、gdb不支持？**    3. **对信号支持不好**

​    优点相对突出，缺点均不是硬伤。Linux下由于实现方法导致进程、线程差别不是很大。



### pthread_self

```c
   #include <pthread.h>

   pthread_t pthread_self(void);
```

返回调用线程的线程id，本函数对应进程的getpid函数

> 在Linux系统中，pthread_t类型是用unsigned long int实现，而其他的UNIX系统中可能用其他类型（结构体）实现

##### 需要注意

* 线程id是进程内部用于识别线程的标志，不要跨进程使用，两个进程的线程id可能相同
* 线程id和ps -Lf看到的LWP不是一个东西，后者是线程号，是给CPU用来划分时间片的
* 在编码中，不要声明pthread_t类型的全局变量
* 该函数和后续的线程相关函数在编译链接时需要加参数-lpthread



### pthread_create

```c
   #include <pthread.h>

   int pthread_create(pthread_t *thread, const pthread_attr_t *attr,
                      void *(*start_routine) (void *), void *arg);
```

创建一个新线程，本函数对应进程的fork函数，参数信息如下：

* thread：出参，返回新线程的线程id（不能为NULL）
* attr：入参，设置新线程的属性，如果使用线程的默认属性，设置为NULL
* start_routine：入参，设置线程的启动函数
* arg：入参，设置线程启动函数的入参，如果线程的启动函数不需要入参，设置为NULL

创建成功返回0，**异常错误返回errno**，并且*thread的内容是未定义的

> 创建的子线程会去执行start_routine函数，而主线程会继续按照原流程继续执行，可以看出线程的栈空间是不共享的

下面有一个循环创建子线程的**陷阱代码**demo：

```c
#include <iostream>
#include <unistd.h>

using namespace std;

void sys_err(const char *s) {
    perror(s);
    exit(EXIT_FAILURE);
}

void *func(void *arg) {
    cout << "thread " << *(int *)arg << endl;
    return nullptr;
}

int main(int argc, char *argv[]) {
    pthread_t tid{};
    for (int i = 0; i < 5; ++i) {  // 循环创建5个子线程
        auto ret =pthread_create(&tid, nullptr, func, &i);  // 将i的值作为线程启动函数入参
        if (0 != ret) {
            sys_err("pthread_create error");
        }
    }
    sleep(1);  // 防止main函数提前结束而导致创建的5个线程无法执行完全，可以换成pthread_exit(NULL)
}
```

看样子代码没有什么问题，预期的打印结果会如下：

```shell
thread 0
thread 1
thread 2
thread 3
thread 4
```

但是实际的执行结果如下（一种情况）：

```shell
thread 2
thread 2
thread 3
thread 4
thread 5
```

问题在于将i的值作为线程启动函数入参的方式存在问题，这里传入i的时候，传入的是i的地址，线程启动时，也是通过i的地址来访问它的值，但是i的值是在不断变化的，主线程的i在不断累加，导致每个线程在打印i的值时，已经不是创建线程时i的值了

这里可以采取值传递的方法，即将i强制转换成void *类型作为入参，在线程启动函数中再将arg强制转换成long，就可以避免这种情况

> 总结而言，线程启动函数的arg参数传入方式需要慎重，传入地址时，考虑*arg会不会不断变化，如果可能，是否能换成值传递来代替

这个demo还有需要提到的地方：

在main函数中调用了sleep函数将主线程休眠了一段时间，使其他的5个线程先执行完成，如果不这样做，一旦main函数返回到启动例程，内核会释放进程占用的所有资源，并使进程结束运行，其他的五个线程就无法执行完全，不过，**如果在main函数中调用pthread_exit使主线程退出，只要由其他线程存在，不会使进程结束运行**



### pthread_exit

```c
   #include <pthread.h>

   void pthread_exit(void *retval);
```

使调用线程结束运行，本函数对应进程的exit函数

入参retval指向需要返回的数据，如果无返回，retval为NULL

> 若只需要返回整型值，将整型强转成指针类型进行值传递



### phtread_join

```c
   #include <pthread.h>

   int pthread_join(pthread_t thread, void **retval);
```

阻塞等待线程thread终止运行，本函数对应进程的waitpid函数，通过出参retval获取退出线程的返回数据，调用成功返回0，**异常错误返回errno**

> 这里面也可以通过强制转换实现值传递的方式来使线程返回整形值
>
> ```c
> void *func(void *arg) {
>     return (void *)25;  // 将值类型强制转换成指针类型返回
> }
> 
> int main(int argc, char *argv[]) {
>     pthread_t tid{};
>     pthread_create(&tid, nullptr, func, nullptr);
>     long *s{};
>     pthread_join(tid, (void **)&s);
>     cout << (long)s << endl;  // 将指针类型强制转换成long类型
> }
> ```



### phtread_cancel

```c
   #include <pthread.h>

   int pthread_cancel(pthread_t thread);
```

给线程thread发送取消请求，尝试终止该线程运行，本函数对应进程的kill函数（SIGKILL），调用成功返回0，**异常错误返回errno**

给线程发送取消请求后，线程是否终止运行以及是否终止运行取决于线程的可取消状态和取消类型，参见后续两个函数

##### 需要注意

* phtread_cancel只是给线程发送取消请求，只要发送成功就会返回0，但是线程不一定取消并销毁

* 当被取消的线程终止运行后，其他线程可以调用pthread_join函数获取到PTHREAD_CANCELED作为该线程的退出状态值，其值为(void *)-1

  > 被取消的线程相当于自己执行了pthread_exit(PTHREAD_CANCELED)



### pthread_setcancelstate

```c
   #include <pthread.h>

   int pthread_setcancelstate(int state, int *oldstate);
```

设置调用线程的可取消状态，通过入参state参数来设置：

* PTHREAD_CANCEL_ENABLE：线程可以通过phtread_cancel函数取消，这个状态是线程的**默认状态**
* PTHREAD_CANCEL_DISABLE：线程不可以通过phtread_cancel函数取消，如果线程收到了phtread_cancel函数发送的取消请求，该请求会被阻塞，直到线程状态切换回PTHREAD_CANCEL_ENABLE

通过出参oldstate来获取调用线程旧的可取消状态，若调用成功返回0，**异常错误返回errno**



### pthread_setcanceltype

```c
   #include <pthread.h>

   int pthread_setcanceltype(int type, int *oldtype);
```

设置调用线程的取消类型，通过入参state参数来设置：

* THREAD_CANCEL_DEFERRED：线程会推迟处理phtread_cancel函数发送的取消请求，直到线程下一次调用被称为**取消点**的函数才开始取消，这个状态是线程的**默认状态**

  > 即使线程的取消类型是THREAD_CANCEL_DEFERRED，如果信号处理函数中的取消点函数被调用，其效果就好像线程的PTHREAD_CANCEL_ASYNCHRONOUS状态一样，异步取消

* PTHREAD_CANCEL_ASYNCHRONOUS：线程可以被随时取消，通常情况下，线程收到phtread_cancel函数发送的取消请求后就会立即取消，不过系统不保证这一点

通过出参oldstate来获取调用线程旧的取消类型，若调用成功返回0，**异常错误返回errno**

> pthread_setcancelstate和pthread_setcanceltype这两个函数中的set/get操作相对于进程中调用相同函数的其他线程来说是原子的

**取消点**一般是系统调用，可以参见man 7 pthreads



### pthread_testcancel

```c
   #include <pthread.h>

   void pthread_testcancel(void);
```

为调用线程创建一个取消点，以便原本不包含取消点的线程可以相应phtread_cancel函数发送的取消请求，终止线程运行

> 如果调用线程的可取消状态是PTHREAD_CANCEL_DISABLE，或者线程并未收到取消请求，调用该函数没有任何效果